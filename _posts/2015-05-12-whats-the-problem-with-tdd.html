---
layout: post
title: What's the problem with TDD?
description: describes the causes of problems with tdd
date: 2015-05-12 15:04:41.000000000 +01:00
categories: TDD
tags: [tdd]

published: true
type: post
featured: false
author: garfieldmoore

image: 'http://dd03isve2g8o3.cloudfront.net/problem_with_tests.jpeg'

---

<p>Have you ever worked on a system where the tests slow you down?</p>
<p>Do the tests break even with the smallest change?</p>
<p>Are the tests brittle?</p>
<p>Is it really hard to write a test? Lots of setup, mocks and expectations?</p>
<p>I've worked on these and I'm pretty sure I'm not alone.</p>
<p>So what's the problem with TDD?</p>
<h2><strong>Feedback loops</strong></h2>
<p>To understand the problem we have to understand feedback loops.</p>
<p>The use of feedback loops is crucial in engineering; the components in a system provide feedback that reinforces or reduces change.</p>
<p>There are two types of feedback loops; positive and negative.</p>
<p><strong>Negative feedback</strong></p>
<p>Negative feedback loops move systems towards stability.</p>
<p>Negative feedback loops act as a damper to, or prohibits, change.</p>
<p>An example of a negative feedback loop in engineering is the <a href="http://en.wikipedia.org/wiki/Centrifugal_governor">centrifugal governor</a>. This limits the speed of the engine by limiting fuel supply.</p>
<p><strong>Positive feedback</strong></p>
<p>Positive feedback loops moves systems towards instability.</p>
<p>Positive feedback loops reinforce change. A change reinforces itself and creates more of the same change.</p>
<p>An oscillator is an example of a positive feedback loop.</p>
<h2><strong>Tests as a feedback loop</strong></h2>
<p>In much the same way, unit tests are an example of a negative feedback loop.  When one breaks we stop and fix it. It is enforcing stability.</p>
<p>However, tests are also providing feedback when you are writing them. If it’s hard to write a test, your design is likely sub-optimal for the change you are trying to make.</p>
<p>For example, if there are lots of dependencies to mock and expectations to set up, we may have missed a needed abstraction that combines them.</p>
<p>The longer we put up with tests that are getting harder to write, the more our software degrades.</p>
<h2><strong>Designing feedback loops</strong></h2>
<p>We have to be careful how we design our feedback loops. If our tests are too fine grained our feedback loop will be too tight, limiting the changes we can make to our system. This will reduce our ability to change our software.</p>
<p>We need the feedback to ensure we haven't broken anything while at the same time we want to be able to change the implementation details of our software.</p>
<h2><strong>Conclusion</strong></h2>
<p>Our tests are feedback loops, telling us, not only when changes are wrong, but also when our changes cannot easily be supported in the design.</p>
<p>If we ignore our tests it will become harder to work within our system over time.</p>
<p>We need to be careful how fine grained we make our tests; too fine and we won't be able to change our software. Not fine enough and we will inadvertently break some behaviour of our software.</p>
